# 代理连接问题

<cite>
**本文档引用的文件**  
- [config.py](file://src\models\config.py) - *重构为数据类配置模型*
- [github_service.py](file://src\services\github_service.py) - *更新为基于AppConfig的服务实现*
- [logger.py](file://src\utils\logger.py) - *增强双语日志支持*
- [dry_run.py](file://scripts\dry_run.py) - *集成新配置系统*
</cite>

## 更新摘要
**主要变更**  
- 代理配置机制从环境变量驱动重构为数据类模型驱动
- GitHub服务实现从单体类迁移至依赖注入架构
- 日志系统升级为双语支持，增强可读性
- 新增结构化配置模型，提升类型安全与可维护性

## 目录
1. [项目结构分析](#项目结构分析)  
2. [核心配置解析](#核心配置解析)  
3. [代理机制实现原理](#代理机制实现原理)  
4. [日志系统与错误识别](#日志系统与错误识别)  
5. [代理问题排查流程](#代理问题排查流程)  
6. [独立验证与集成测试](#独立验证与集成测试)

## 项目结构分析

本项目为一个自动化密钥扫描与同步工具，主要功能包括从GitHub搜索敏感密钥（如ModelScope API密钥）、通过代理访问受限资源、并支持负载均衡服务同步。项目采用模块化设计，各目录职责清晰。

```mermaid
graph TD
A[src] --> A1[main.py]
B[src.models] --> B1[config.py]
C[src.services] --> C1[github_service.py]
D[scripts] --> D1[dry_run.py]
E[src.utils] --> E1[logger.py]
A1 --> B1
A1 --> C1
C1 --> B1
C1 --> E1
D1 --> B1
D1 --> C1
```

**图示来源**  
- [config.py](file://src\models\config.py)
- [github_service.py](file://src\services\github_service.py)
- [dry_run.py](file://scripts\dry_run.py)

**本节来源**  
- [config.py](file://src\models\config.py)
- [github_service.py](file://src\services\github_service.py)
- [dry_run.py](file://scripts\dry_run.py)

## 核心配置解析

`src/models/config.py` 是整个项目的配置中心，采用数据类（dataclass）实现类型安全的配置管理。其中与代理相关的配置项如下：

- **AppConfig.proxy_list**: 字符串列表，存储原始代理地址，如 `http://user:pass@host:port`。
- **ProxyConfig**: 数据类，封装单个代理的HTTP/HTTPS配置。
- **get_proxy_configs()**: 实例方法，将 `proxy_list` 转换为 `ProxyConfig` 对象列表。

```python
def get_proxy_configs(self) -> List[ProxyConfig]:
    """获取代理配置列表"""
    return [ProxyConfig.from_string(proxy) for proxy in self.proxy_list if proxy.strip()]
```

该方法确保：
- 空字符串代理被过滤
- 每个有效代理字符串转换为标准化的 `ProxyConfig` 对象
- 支持统一的代理管理接口

**本节来源**  
- [config.py](file://src\models\config.py)

## 代理机制实现原理

`src/services/github_service.py` 中的 `GitHubService` 类负责调用 GitHub API 进行代码搜索和文件内容获取。其代理应用逻辑如下：

### 请求流程中的代理注入

在每次发起 `GET` 请求前，会调用 `_get_random_proxy()` 获取代理配置，并将其传入 `requests.get()` 方法：

```python
proxies = self._get_random_proxy()
response = requests.get(
    self.api_url,
    headers=headers,
    params=params,
    timeout=30,
    proxies=proxies
)
```

### 代理选择机制

`_get_random_proxy()` 方法实现随机代理轮换：

```python
def _get_random_proxy(self) -> Optional[Dict[str, str]]:
    if not self.proxies:
        return None
    proxy_config = random.choice(self.proxies)
    return {
        'http': proxy_config.http,
        'https': proxy_config.https
    } if proxy_config.http or proxy_config.https else None
```

此机制确保：
- 若未配置代理，则 `proxies` 为 `None`，直接直连
- 若配置了多个代理，则每次请求随机选择一个，实现简单的负载均衡
- 支持不同协议的独立配置（HTTP/HTTPS）

### 代理格式支持

支持标准的 URL 格式代理：
- `http://proxy.example.com:8080`
- `http://user:password@proxy.example.com:8080`
- `socks5://proxy.example.com:1080`

> ⚠️ 注意：若代理地址格式错误（如缺少协议头、端口非法），将导致 `requests` 抛出异常。

```mermaid
sequenceDiagram
participant Service as GitHubService
participant Config as AppConfig
participant Requests as requests库
participant Proxy as 代理服务器
participant GitHub as GitHub API
Service->>Config : get_proxy_configs()
Config-->>Service : 返回ProxyConfig列表
Service->>Service : _get_random_proxy()
Service-->>Service : 返回随机代理字典
Service->>Requests : 发起GET请求含proxies
alt 代理配置存在
Requests->>Proxy : 通过代理转发请求
Proxy->>GitHub : 转发请求
GitHub-->>Proxy : 返回响应
Proxy-->>Requests : 返回响应
else 无代理配置
Requests->>GitHub : 直连请求
GitHub-->>Requests : 返回响应
end
Requests-->>Service : 返回响应对象
```

**图示来源**  
- [github_service.py](file://src\services\github_service.py)
- [config.py](file://src\models\config.py)

**本节来源**  
- [github_service.py](file://src\services\github_service.py)
- [config.py](file://src\models\config.py)

## 日志系统与错误识别

`src/utils/logger.py` 提供了增强的双语结构化日志输出功能，便于识别代理相关错误。最近的重构增强了日志功能，特别是针对网络操作的记录。

### 日志级别说明

| 日志级别 | 输出格式 | 用途 |
|--------|--------|------|
| info | 白色文本 | 正常流程、统计信息 |
| warning | 黄色文本 | 可恢复警告（如速率限制接近） |
| error | 红色文本 + 分隔线 | 严重错误（如连接失败、认证失败） |

### 新增网络日志方法

在最近的重构中，`Logger` 类新增了 `network()` 方法，专门用于记录网络相关操作，使用 🌐 图标进行标识。

```python
def network(self, message: str, *args, **kwargs):
    """网络相关日志"""
    if hasattr(self._logger, 'network'):
        self._safe_log(self._logger.network, message, *args, **kwargs)
    else:
        msg = f"🌐 网络 Network {message}"
        self._safe_log(self._logger.info, msg, *args, **kwargs)
```

该方法在以下场景中被调用：

**在 `github_service.py` 中：**
```python
print(f"🌐 Fetching: {metadata_url}")
```

**在 `logger.py` 中：**
```python
self.network_request("GitHub", "search_code")
```

### 关键错误日志识别

#### 1. 代理连接超时
```log
❌ Network error after 5 attempts on page 1: Timeout
```
- **含义**：连续5次尝试均超时，可能是代理不可达或网络阻塞。
- **可能原因**：代理地址错误、防火墙拦截、代理服务器宕机。

#### 2. SSL握手失败
```log
❌ Network error after 5 attempts on page 1: SSLError
```
- **含义**：SSL/TLS 握手失败。
- **可能原因**：代理服务器证书不受信任、中间人攻击、`requests` 库未正确处理代理的SSL。

#### 3. 代理认证失败
```log
❌ HTTP 407 error after 5 attempts on page 1
```
- **含义**：HTTP 407 Proxy Authentication Required。
- **可能原因**：代理用户名/密码错误、认证方式不支持（如NTLM）。

#### 4. 速率限制警告
```log
⚠️ Rate limit low: 2 remaining, token: xxxxx
```
- **含义**：当前Token剩余请求次数低于3次。
- **注意**：此为GitHub速率限制，非代理限制。

**本节来源**  
- [logger.py](file://src\utils\logger.py) - *增强双语日志支持*
- [github_service.py](file://src\services\github_service.py) - *使用print输出网络请求*
- [config.py](file://src\models\config.py) - *提供配置数据*

## 代理问题排查流程

当出现代理连接问题时，请按以下步骤逐步排查：

### 第一步：验证代理可达性

使用 `curl` 命令行工具独立测试代理是否可用：

```bash
# 测试HTTP代理
curl -x http://user:pass@proxy.example.com:8080 -I https://api.github.com

# 测试SOCKS5代理
curl --socks5-hostname user:pass@proxy.example.com:1080 -I https://api.github.com
```

- ✅ 成功：返回 `HTTP/2 200` 或 `HTTP/1.1 200 OK`
- ❌ 失败：检查错误信息（如 `Connection timed out`、`407 Proxy Authentication Required`）

### 第二步：检查防火墙与网络策略

- 确认本地防火墙未阻止出站连接。
- 确认代理服务器端口（如8080、1080）在防火墙中开放。
- 若在企业网络中，确认IT策略允许使用外部代理。

### 第三步：测试基础网络连通性

```bash
# 测试DNS解析
nslookup proxy.example.com

# 测试端口连通性
telnet proxy.example.com 8080
# 或使用 PowerShell
Test-NetConnection proxy.example.com -Port 8080
```

### 第四步：检查代理格式与配置

确认配置文件中 `proxy_list` 变量格式正确：

```python
# 正确示例
proxy_list = [
    "http://user:pass@192.168.1.100:8080",
    "socks5://192.168.1.101:1080"
]
```

### 第五步：启用调试日志

在 `github_service.py` 中临时添加调试日志，确认 `proxies` 参数是否正确传递：

```python
print(f"Debug: Using proxies = {proxies}")
```

**本节来源**  
- [config.py](file://src\models\config.py)
- [github_service.py](file://src\services\github_service.py)

## 独立验证与集成测试

### 使用 `dry_run.py` 进行集成测试

`scripts/dry_run.py` 提供了一个轻量级的集成测试脚本，可用于验证密钥提取逻辑和代理配置是否生效。

#### 执行步骤：

1. 确保配置已正确加载 `proxy_list`。
2. 运行测试脚本：
   ```bash
   python scripts/dry_run.py
   ```
3. 观察输出：
   - 若成功：显示 `[dry-run] 提取成功并已写入`
   - 若失败：结合日志判断是代理问题还是逻辑问题。

#### 测试目的：
- 验证代理配置能否成功加载。
- 验证 `requests` 是否能通过代理获取外部资源（模拟GitHub API调用）。
- 验证密钥提取逻辑是否正常。

**本节来源**  
- [dry_run.py](file://scripts\dry_run.py)
- [config.py](file://src\models\config.py)