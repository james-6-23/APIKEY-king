# 代理支持与网络配置

<cite>
**本文档引用的文件**  
- [common\config.py](file://common/config.py)
- [utils\github_client.py](file://utils/github_client.py)
- [app\hajimi_king.py](file://app/hajimi_king.py)
- [utils\sync_utils.py](file://utils/sync_utils.py)
</cite>

## 目录
1. [引言](#引言)
2. [代理配置机制](#代理配置机制)
3. [GitHub API请求中的代理集成](#github-api请求中的代理集成)
4. [SOCKS代理与高级配置](#socks代理与高级配置)
5. [超时与网络稳定性优化](#超时与网络稳定性优化)
6. [实际应用场景分析](#实际应用场景分析)
7. [依赖关系与架构图](#依赖关系与架构图)
8. [故障排查指南](#故障排查指南)
9. [总结](#总结)

## 引言
APIKEY-king 是一个用于扫描 GitHub 上泄露的 API 密钥（如 Google Gemini、ModelScope）的工具。在实际运行中，由于 GitHub 的访问限制或本地网络环境的限制，直接请求可能失败或被限流。为此，项目提供了灵活的代理支持机制，允许通过 HTTP/HTTPS/SOCKS 代理转发请求，从而绕过网络限制、提升扫描稳定性。

本文档将深入解析 APIKEY-king 的代理配置机制，涵盖从环境变量设置、配置文件解析，到 `requests` 库的实际集成全过程，并提供最佳实践建议。

## 代理配置机制

APIKEY-king 的代理配置主要通过环境变量 `PROXY` 实现，其逻辑在 `common/config.py` 文件中定义。

### 环境变量与配置解析
代理配置的核心是 `PROXY_LIST_STR` 环境变量，它接受一个逗号分隔的代理 URL 列表。每个代理 URL 可以是以下格式：
- `http://user:pass@host:port`
- `https://host:port`
- `socks5://user:pass@host:port`

在 `config.py` 中，`Config` 类通过以下代码解析该环境变量：

```python
PROXY_LIST_STR = os.getenv("PROXY", "")
PROXY_LIST = []
if PROXY_LIST_STR:
    for proxy_str in PROXY_LIST_STR.split(','):
        proxy_str = proxy_str.strip()
        if proxy_str:
            PROXY_LIST.append(proxy_str)
```

此代码将环境变量字符串分割并存入 `PROXY_LIST` 列表，供后续使用。

### 随机代理选择
为了负载均衡和避免单个代理过载，系统提供了 `get_random_proxy()` 类方法，用于从代理列表中随机选择一个代理：

```python
@classmethod
def get_random_proxy(cls) -> Optional[Dict[str, str]]:
    if not cls.PROXY_LIST:
        return None
    proxy_url = random.choice(cls.PROXY_LIST).strip()
    return {
        'http': proxy_url,
        'https': proxy_url
    }
```

该方法返回一个符合 `requests` 库要求的字典格式，同时为 `http` 和 `https` 请求设置相同的代理地址。

**Section sources**
- [common\config.py](file://common/config.py#L15-L203)

## GitHub API请求中的代理集成

代理的实际应用发生在 `utils/github_client.py` 文件中的 `GitHubClient` 类，该类负责与 GitHub API 交互。

### 在搜索请求中注入代理
当执行代码搜索时，`search_for_keys` 方法会调用 `Config.get_random_proxy()` 获取代理配置，并将其注入 `requests.get()` 调用中：

```python
proxies = Config.get_random_proxy()
if proxies:
    response = requests.get(self.GITHUB_API_URL, headers=headers, params=params, timeout=30, proxies=proxies)
else:
    response = requests.get(self.GITHUB_API_URL, headers=headers, params=params, timeout=30)
```

此逻辑确保了：
- 如果配置了代理，则使用代理发送请求。
- 如果未配置代理，则直接发送请求。

### 在获取文件内容时使用代理
同样，在获取文件内容的 `get_file_content` 方法中，也集成了相同的代理逻辑：

```python
proxies = Config.get_random_proxy()
if proxies:
    metadata_response = requests.get(metadata_url, headers=headers, proxies=proxies)
else:
    metadata_response = requests.get(metadata_url, headers=headers)
```

这保证了所有对外的 HTTP 请求都能通过代理进行，增强了网络的灵活性和稳定性。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant GitHubClient as "GitHubClient"
participant Config as "Config"
participant Requests as "requests库"
participant GitHubAPI as "GitHub API"
Client->>GitHubClient : search_for_keys(query)
GitHubClient->>Config : get_random_proxy()
Config-->>GitHubClient : 返回代理配置
GitHubClient->>Requests : 发起GET请求
alt 代理已配置
Requests->>GitHubAPI : 通过代理连接
else 无代理
Requests->>GitHubAPI : 直接连接
end
GitHubAPI-->>Requests : 返回响应
Requests-->>GitHubClient : 返回响应
GitHubClient-->>Client : 返回搜索结果
```

**Diagram sources**
- [utils\github_client.py](file://utils/github_client.py#L60-L217)
- [common\config.py](file://common/config.py#L15-L203)

**Section sources**
- [utils\github_client.py](file://utils/github_client.py#L60-L217)

## SOCKS代理与高级配置

APIKEY-king 支持 SOCKS 代理，这为在复杂网络环境（如企业内网、特定地区）下运行提供了便利。

### 配置示例
要使用 SOCKS5 代理，可以在 `.env` 文件或环境变量中设置：

```env
PROXY=socks5://username:password@proxy-server.com:1080,http://proxy2.com:8080
```

或者，如果代理不需要认证：

```env
PROXY=socks5://192.168.1.100:1080,http://192.168.1.101:8080
```

### 注意事项
- **依赖库**：Python 的 `requests` 库本身不支持 SOCKS 代理，需要安装 `requests[socks]` 依赖。通常通过 `pip install requests[socks]` 安装，它会自动引入 `PySocks` 库。
- **协议兼容性**：确保代理服务器支持指定的协议（SOCKS4、SOCKS5）。
- **性能**：SOCKS 代理可能比 HTTP 代理有更高的延迟，需根据实际情况调整超时设置。

**Section sources**
- [common\config.py](file://common/config.py#L15-L203)

## 超时与网络稳定性优化

在高延迟或不稳定的网络环境下，合理的超时设置至关重要，以避免请求长时间挂起或频繁失败。

### 当前超时设置分析
在 `github_client.py` 中，`requests.get()` 调用设置了 `timeout=30`，这是一个全局超时，意味着连接和读取的总时间不能超过30秒。

```python
response = requests.get(..., timeout=30)
```

在 `sync_utils.py` 中，向外部负载均衡器发送密钥时也设置了超时：
- 获取配置：`timeout=30`
- 更新配置：`timeout=60`

### 最佳实践建议
1. **动态超时**：根据网络状况动态调整超时时间。例如，可以引入一个 `TIMEOUT` 环境变量。
2. **分阶段超时**：使用元组形式的超时 `(连接超时, 读取超时)`，例如 `timeout=(10, 30)`，以更精细地控制。
3. **重试机制**：当前代码已有基于指数退避的重试逻辑（`max_retries`），这是应对网络抖动的有效手段。
4. **监控与日志**：通过日志记录超时事件（如 `sync_utils.py` 中的 `logger.error("❌ Request timeout...")`），便于分析网络问题。

```mermaid
flowchart TD
A[发起HTTP请求] --> B{是否配置代理?}
B --> |是| C[使用代理配置]
B --> |否| D[直接连接]
C --> E[设置超时: 30秒]
D --> E
E --> F[发送请求]
F --> G{响应成功?}
G --> |是| H[处理响应]
G --> |否| I{是否超时?}
I --> |是| J[记录超时日志]
I --> |否| K[其他网络错误]
J --> L[执行重试逻辑]
K --> L
L --> M{达到最大重试次数?}
M --> |否| F
M --> |是| N[放弃并报错]
```

**Diagram sources**
- [utils\github_client.py](file://utils/github_client.py#L60-L217)
- [utils\sync_utils.py](file://utils/sync_utils.py#L125-L395)

**Section sources**
- [utils\github_client.py](file://utils/github_client.py#L60-L217)
- [utils\sync_utils.py](file://utils/sync_utils.py#L125-L395)

## 实际应用场景分析

### 绕过网络限制
在某些网络环境中，直接访问 `api.github.com` 可能被防火墙阻止。通过配置代理，APIKEY-king 可以将流量路由到可访问的服务器，从而成功执行扫描任务。

### 提升扫描稳定性
- **避免IP封禁**：GitHub 对 API 请求有严格的速率限制。使用多个代理可以分散请求来源的IP，降低单个IP被封禁的风险。
- **高可用性**：当一个代理服务器宕机时，`get_random_proxy()` 方法可以从列表中选择另一个可用的代理，保证扫描任务的连续性。

### 企业级部署
在企业环境中，所有出站流量通常必须通过公司代理。APIKEY-king 的代理支持使其能够无缝集成到此类环境中，无需修改网络策略。

**Section sources**
- [app\hajimi_king.py](file://app/hajimi_king.py#L1-L523)
- [utils\github_client.py](file://utils/github_client.py#L1-L217)

## 依赖关系与架构图

```mermaid
graph TB
subgraph "配置层"
Config[config.py<br>读取环境变量<br>PROXY_LIST]
end
subgraph "核心逻辑层"
GitHubClient[github_client.py<br>GitHubClient<br>search_for_keys<br>get_file_content]
SyncUtils[sync_utils.py<br>SyncUtils<br>发送密钥到负载均衡器]
end
subgraph "应用层"
Main[hajimi_king.py<br>主程序入口<br>调用GitHubClient]
end
Config --> |提供代理配置| GitHubClient
Config --> |提供代理配置| SyncUtils
GitHubClient --> |执行搜索| Main
SyncUtils --> |异步发送| Main
style Config fill:#f9f,stroke:#333
style GitHubClient fill:#bbf,stroke:#333
style SyncUtils fill:#bbf,stroke:#333
style Main fill:#f96,stroke:#333
```

**Diagram sources**
- [common\config.py](file://common/config.py#L15-L203)
- [utils\github_client.py](file://utils/github_client.py#L1-L217)
- [utils\sync_utils.py](file://utils/sync_utils.py#L1-L484)
- [app\hajimi_king.py](file://app/hajimi_king.py#L1-L523)

## 故障排查指南

当代理功能出现问题时，可参考以下步骤进行排查：

1. **检查环境变量**：
   - 确认 `PROXY` 环境变量已正确设置，且格式无误。
   - 检查是否有拼写错误，如 `PROX` 或 `PROXY_URL`。

2. **验证代理可用性**：
   - 使用 `curl` 或 `telnet` 手动测试代理服务器是否可达。
   - 例如：`curl --proxy socks5://user:pass@host:port https://api.github.com`

3. **检查依赖库**：
   - 如果使用 SOCKS 代理，确保已安装 `requests[socks]`。
   - 运行 `pip list | grep PySocks` 检查 `PySocks` 是否存在。

4. **查看日志输出**：
   - 检查程序日志中是否有 `Request timeout` 或 `Connection failed` 等错误。
   - 日志会明确指出是哪个组件（如 balancer）连接超时。

5. **临时禁用代理**：
   - 将 `PROXY` 环境变量留空或删除，测试是否能在无代理情况下工作，以确定问题是否出在代理本身。

**Section sources**
- [common\config.py](file://common/config.py#L15-L203)
- [utils\github_client.py](file://utils/github_client.py#L1-L217)
- [utils\sync_utils.py](file://utils/sync_utils.py#L1-L484)

## 总结
APIKEY-king 通过 `config.py` 中的 `PROXY` 环境变量实现了灵活的代理支持。`Config` 类负责解析和管理代理列表，并提供随机选择功能。`github_client.py` 和 `sync_utils.py` 在发起 HTTP 请求时，会动态注入代理配置，确保所有网络请求都能通过代理进行。这一机制不仅支持标准的 HTTP/HTTPS 代理，也兼容 SOCKS 代理，极大地增强了工具在受限网络环境下的适应性和稳定性。结合合理的超时设置和重试策略，APIKEY-king 能够在各种复杂的网络条件下高效、可靠地运行。