# 密钥搜索功能

<cite>
**本文档中引用的文件**  
- [hajimi_king.py](file://app/hajimi_king.py) - *新增 OpenRouter 密钥提取功能*
- [github_client.py](file://utils/github_client.py)
- [config.py](file://common/config.py) - *新增 OpenRouter 相关配置项*
- [file_manager.py](file://utils/file_manager.py)
- [queries.openrouter.txt](file://queries.openrouter.txt) - *新增 OpenRouter 专用查询文件*
- [OPENROUTER_USAGE.md](file://OPENROUTER_USAGE.md) - *新增使用说明文档*
</cite>

## 更新摘要
**变更内容**  
- 新增 OpenRouter API 密钥提取功能，优先级高于 Gemini 密钥
- 更新密钥搜索机制，增加 OpenRouter 专用查询语法
- 新增 `openrouter-only` 命令行模式
- 更新配置文件以支持 OpenRouter 提取参数
- 移除已废弃的 `sync_utils.py` 同步功能

## 目录
1. [项目结构](#项目结构)  
2. [核心组件](#核心组件)  
3. [密钥搜索机制](#密钥搜索机制)  
4. [多令牌轮换策略](#多令牌轮换策略)  
5. [代理支持与网络集成](#代理支持与网络集成)  
6. [查询参数动态生成](#查询参数动态生成)  
7. [结果分页与错误重试](#结果分页与错误重试)  
8. [性能优化建议](#性能优化建议)

## 项目结构

项目采用模块化设计，主要分为应用层、通用配置、工具类和脚本四大部分。整体结构清晰，职责分离明确。

```mermaid
graph TB
subgraph "应用层"
A[hajimi_king.py]
end
subgraph "通用模块"
B[Logger.py]
C[config.py]
end
subgraph "工具类"
D[github_client.py]
E[file_manager.py]
end
subgraph "脚本"
G[start_openrouter_only.py]
end
A --> D
A --> E
D --> C
E --> C
A --> B
D --> B
E --> B
```

**图示来源**  
- [hajimi_king.py](file://app/hajimi_king.py)
- [github_client.py](file://utils/github_client.py)
- [config.py](file://common/config.py)
- [file_manager.py](file://utils/file_manager.py)

## 核心组件

系统由四大核心模块构成：主控制器 `hajimi_king.py`、GitHub客户端 `github_client.py`、全局配置 `config.py` 和文件管理器 `file_manager.py`。

- **hajimi_king.py**：主程序入口，负责协调搜索、处理和验证流程，新增 OpenRouter 密钥提取逻辑
- **github_client.py**：封装GitHub API调用，实现代码搜索与内容获取
- **config.py**：集中管理所有配置项，包括令牌、代理、路径等，新增 OpenRouter 配置
- **file_manager.py**：负责文件读写、日志记录和检查点管理

**组件来源**  
- [hajimi_king.py](file://app/hajimi_king.py)
- [github_client.py](file://utils/github_client.py)
- [config.py](file://common/config.py)
- [file_manager.py](file://utils/file_manager.py)

## 密钥搜索机制

### 搜索流程概述

密钥搜索流程始于 `hajimi_king.py` 中的 `main()` 函数，通过调用 `GitHubClient` 实例发起搜索请求，完整流程如下：

1. 加载配置与检查点
2. 读取搜索查询语句
3. 遍历每个查询并调用 `search_for_keys()`
4. 处理返回结果中的每个文件项
5. 优先提取并保存 OpenRouter 或 ModelScope 密钥
6. 若未找到，根据模式决定是否回退到 Gemini 密钥提取
7. 保存结果并更新检查点

### ModelScope 密钥搜索语法

针对 ModelScope 密钥（格式为 `ms-UUID`），系统采用特定搜索语法，确保只在包含目标API地址的文件中提取密钥。

#### 查询语法示例：
```
"https://api-inference.modelscope.cn/v1/" in:file
```

该查询语句会匹配所有包含 ModelScope API 基地址的代码文件，从而缩小搜索范围，提高准确性。

#### 提取逻辑实现：

```python
def extract_ms_keys_for_modelscope(content: str) -> List[str]:
    base_urls = Config.TARGET_BASE_URLS
    has_base, base_positions = _contains_base_url(content, base_urls)
    if not has_base:
        return []

    strict_pat = r'(?i)\bms-[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b'
    loose_pat = r'(?i)\bms-[0-9a-f-]{30,}\b'
    use_loose = Config.parse_bool(Config.MS_USE_LOOSE_PATTERN)
    pattern = loose_pat if use_loose else strict_pat
    ...
```

此函数首先检查文件内容是否包含 `TARGET_BASE_URLS` 中任一URL，若存在则使用正则表达式提取符合 `ms-UUID` 格式的密钥。

### OpenRouter 密钥搜索语法

OpenRouter 密钥以 `sk-or-v1-` 开头，系统使用以下正则表达式进行提取：

```python
def extract_openrouter_keys(content: str) -> List[str]:
    """
    当同一文件中包含 Config.OPENROUTER_BASE_URLS 任一值时，提取 OpenRouter API keys。
    OpenRouter key 格式: sk-or-v1-[64位十六进制字符串]
    """
    base_urls = Config.OPENROUTER_BASE_URLS
    has_base, base_positions = _contains_base_url(content, base_urls)
    if not has_base:
        return []

    strict_pat = r'\bsk-or-v1-[0-9a-f]{64}\b'
    loose_pat = r'\bsk-or-v1-[0-9a-f]{40,}\b'
    use_loose = Config.parse_bool(Config.OPENROUTER_USE_LOOSE_PATTERN)
    pattern = loose_pat if use_loose else strict_pat
    ...
```

典型搜索查询包括：
```
"https://openrouter.ai/api/v1" in:file
openrouter.ai in:file
sk-or-v1- in:file filename:.env
```

这些查询语句利用 GitHub 代码搜索语法，限定在文件内容中搜索，并可进一步按文件名过滤。

**代码来源**  
- [hajimi_king.py](file://app/hajimi_king.py#L150-L200)
- [config.py](file://common/config.py#L70-L85)
- [queries.openrouter.txt](file://queries.openrouter.txt)

### Gemini 密钥搜索语法

Gemini 密钥以 `AIzaSy` 开头，系统使用以下正则表达式进行提取：

```python
def extract_keys_from_content(content: str) -> List[str]:
    pattern = r'(AIzaSy[A-Za-z0-9\-_]{33})'
    return re.findall(pattern, content)
```

典型搜索查询包括：
```
AIzaSy in:file
AIzaSy in:file filename:.env
```

这些查询语句利用 GitHub 代码搜索语法，限定在文件内容中搜索，并可进一步按文件名过滤。

**代码来源**  
- [hajimi_king.py](file://app/hajimi_king.py#L108-L158)
- [github_client.py](file://utils/github_client.py#L50-L100)

## 多令牌轮换策略

### 实现原理

为避免单个 GitHub 令牌因速率限制被封禁，系统实现了多令牌轮换机制。`GitHubClient` 类维护一个令牌列表，并通过 `_token_ptr` 指针实现循环调度。

```python
class GitHubClient:
    def __init__(self, tokens: List[str]):
        self.tokens = [token.strip() for token in tokens if token.strip()]
        self._token_ptr = 0

    def _next_token(self) -> Optional[str]:
        if not self.tokens:
            return None
        token = self.tokens[self._token_ptr % len(self.tokens)]
        self._token_ptr += 1
        return token.strip()
```

每次发起请求前调用 `_next_token()` 获取下一个令牌，实现负载均衡。

### 轮换优势

- **避免速率限制**：GitHub 对每个令牌每小时有 30 次搜索请求限制，多令牌可显著提升总请求数。
- **提高扫描效率**：多个令牌并行使用，缩短整体扫描时间。
- **容错性强**：个别令牌失效不影响整体流程。

**代码来源**  
- [github_client.py](file://utils/github_client.py#L11-L35)

## 代理支持与网络集成

### 配置方式

代理通过环境变量 `PROXY` 配置，支持多种协议（HTTP、HTTPS、SOCKS5），多个代理以逗号分隔：

```env
PROXY=http://user:pass@host:port,socks5://host:port
```

在 `config.py` 中解析为列表：

```python
PROXY_LIST_STR = os.getenv("PROXY", "")
PROXY_LIST = []
if PROXY_LIST_STR:
    for proxy_str in PROXY_LIST_STR.split(','):
        proxy_str = proxy_str.strip()
        if proxy_str:
            PROXY_LIST.append(proxy_str)
```

### 集成路径

代理在 `github_client.py` 和 `hajimi_king.py` 中动态注入：

```python
# 在 github_client.py 中
proxies = Config.get_random_proxy()
if proxies:
    response = requests.get(url, headers=headers, params=params, timeout=30, proxies=proxies)

# 在 validate_gemini_key 中
proxy_config = Config.get_random_proxy()
if proxy_config:
    os.environ['grpc_proxy'] = proxy_config.get('http')
```

每次请求随机选择一个代理，增强匿名性和稳定性。

**代码来源**  
- [config.py](file://common/config.py#L15-L25)
- [github_client.py](file://utils/github_client.py#L75-L80)
- [hajimi_king.py](file://app/hajimi_king.py#L312-L318)

## 查询参数动态生成

### 动态参数逻辑

系统支持动态生成查询参数，如语言过滤、时间范围等，通过配置文件和代码逻辑共同控制。

#### 语言过滤示例：
```python
# queries.openrouter.txt
"openrouter" in:file language:python
"openrouter" in:file language:javascript
```

#### 时间范围过滤：
通过 `DATE_RANGE_DAYS` 配置项控制，默认为 730 天（约2年）：

```python
if repo_pushed_dt < datetime.utcnow() - timedelta(days=Config.DATE_RANGE_DAYS):
    skip_stats["age_filter"] += 1
    return True, "age_filter"
```

### 查询规范化

为避免重复执行相同查询，系统对查询语句进行规范化处理：

```python
def normalize_query(query: str) -> str:
    parts = query.split()
    # 按类型分类排序
    quoted_strings = [p for p in parts if p.startswith('"')]
    other_parts = [p for p in parts if not p.startswith(('"', 'language:', 'filename:', 'path:'))]
    language_parts = [p for p in parts if p.startswith('language:')]
    ...
    return " ".join(sorted(quoted_strings) + sorted(other_parts) + sorted(language_parts) + ...)
```

确保相同语义的查询被视为同一请求。

**代码来源**  
- [hajimi_king.py](file://app/hajimi_king.py#L25-L105)
- [config.py](file://common/config.py#L50-L51)

## 结果分页与错误重试

### 分页处理

GitHub 搜索 API 每页最多返回 100 条结果，最多返回前 1000 条。系统通过分页机制获取全部结果：

```python
for page in range(1, 11):
    params = {"q": query, "per_page": 100, "page": page}
    response = requests.get(GITHUB_API_URL, params=params, ...)
    items = response.json().get("items", [])
    all_items.extend(items)
    if len(all_items) >= expected_total:
        break
```

最多请求 10 页（1000 条），并根据 `total_count` 判断是否完整。

### 错误重试机制

系统对网络错误和速率限制实现指数退避重试：

```python
for attempt in range(1, max_retries + 1):
    try:
        response = requests.get(...)
        response.raise_for_status()
        break
    except requests.exceptions.HTTPError as e:
        if status in (403, 429):
            wait = min(2 ** attempt + random.uniform(0, 1), 60)
            time.sleep(wait)
            continue
```

- 最多重试 5 次
- 等待时间随尝试次数指数增长
- 最大等待 60 秒

### 实际 HTTP 请求示例

**请求：**
```
GET /search/code?q=AIzaSy+in%3Afile&per_page=100&page=1
Host: api.github.com
Authorization: token ghp_xxx
Accept: application/vnd.github.v3+json
```

**响应：**
```json
{
  "total_count": 42,
  "incomplete_results": false,
  "items": [
    {
      "name": "config.json",
      "path": "src/config.json",
      "sha": "a1b2c3d4",
      "html_url": "https://github.com/user/repo/blob/main/src/config.json",
      "repository": { "full_name": "user/repo", "pushed_at": "2023-01-01T12:00:00Z" }
    }
  ]
}
```

**代码来源**  
- [github_client.py](file://utils/github_client.py#L50-L150)

## 性能优化建议

### 1. 合理配置多令牌
- 建议配置 3-5 个 GitHub 令牌，以平衡速率限制与管理复杂度。
- 定期轮换令牌，避免长期使用导致封禁。

### 2. 优化查询语句
- 使用精确匹配（如 `filename:.env`）减少无效结果。
- 结合 `language:` 过滤目标语言文件。
- 避免过于宽泛的查询，防止返回过多无关结果。

### 3. 启用代理池
- 配置多个稳定代理，提升请求成功率。
- 使用支持认证的代理服务，增强安全性。

### 4. 调整扫描频率
- 增量扫描模式下，合理设置 `DATE_RANGE_DAYS`，避免重复扫描旧仓库。
- 生产环境建议设置为 30-90 天。

### 5. 监控与日志分析
- 定期检查日志中的 `rate_limit` 警告，及时调整策略。
- 分析 `skip_stats` 统计信息，优化过滤规则。

### 6. 异步处理优化
- 主流程已移除同步功能，专注于密钥提取。
- 可根据网络状况调整 `batch_interval`（默认 60 秒）。

**最佳实践来源**  
- [hajimi_king.py](file://app/hajimi_king.py)
- [github_client.py](file://utils/github_client.py)
- [config.py](file://common/config.py)